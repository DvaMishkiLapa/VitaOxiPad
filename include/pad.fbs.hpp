// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PAD_PAD_H_
#define FLATBUFFERS_GENERATED_PAD_PAD_H_

#include "flatbuffers/flatbuffers.h"

namespace Pad {

struct ButtonsData;

struct Vector3;

struct MotionData;

struct TouchReport;

struct TouchData;
struct TouchDataBuilder;

struct MainPacket;
struct MainPacketBuilder;

enum class TouchPort : uint8_t {
  Front = 0,
  Back = 1,
  MIN = Front,
  MAX = Back
};

inline const TouchPort (&EnumValuesTouchPort())[2] {
  static const TouchPort values[] = {
    TouchPort::Front,
    TouchPort::Back
  };
  return values;
}

inline const char * const *EnumNamesTouchPort() {
  static const char * const names[3] = {
    "Front",
    "Back",
    nullptr
  };
  return names;
}

inline const char *EnumNameTouchPort(TouchPort e) {
  if (flatbuffers::IsOutRange(e, TouchPort::Front, TouchPort::Back)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTouchPort()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) ButtonsData FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t select_;
  uint8_t start_;
  uint8_t up_;
  uint8_t right_;
  uint8_t down_;
  uint8_t left_;
  uint8_t lt_;
  uint8_t rt_;
  uint8_t triangle_;
  uint8_t circle_;
  uint8_t cross_;
  uint8_t square_;

 public:
  ButtonsData() {
    memset(static_cast<void *>(this), 0, sizeof(ButtonsData));
  }
  ButtonsData(bool _select, bool _start, bool _up, bool _right, bool _down, bool _left, bool _lt, bool _rt, bool _triangle, bool _circle, bool _cross, bool _square)
      : select_(flatbuffers::EndianScalar(static_cast<uint8_t>(_select))),
        start_(flatbuffers::EndianScalar(static_cast<uint8_t>(_start))),
        up_(flatbuffers::EndianScalar(static_cast<uint8_t>(_up))),
        right_(flatbuffers::EndianScalar(static_cast<uint8_t>(_right))),
        down_(flatbuffers::EndianScalar(static_cast<uint8_t>(_down))),
        left_(flatbuffers::EndianScalar(static_cast<uint8_t>(_left))),
        lt_(flatbuffers::EndianScalar(static_cast<uint8_t>(_lt))),
        rt_(flatbuffers::EndianScalar(static_cast<uint8_t>(_rt))),
        triangle_(flatbuffers::EndianScalar(static_cast<uint8_t>(_triangle))),
        circle_(flatbuffers::EndianScalar(static_cast<uint8_t>(_circle))),
        cross_(flatbuffers::EndianScalar(static_cast<uint8_t>(_cross))),
        square_(flatbuffers::EndianScalar(static_cast<uint8_t>(_square))) {
  }
  bool select() const {
    return flatbuffers::EndianScalar(select_) != 0;
  }
  void mutate_select(bool _select) {
    flatbuffers::WriteScalar(&select_, static_cast<uint8_t>(_select));
  }
  bool start() const {
    return flatbuffers::EndianScalar(start_) != 0;
  }
  void mutate_start(bool _start) {
    flatbuffers::WriteScalar(&start_, static_cast<uint8_t>(_start));
  }
  bool up() const {
    return flatbuffers::EndianScalar(up_) != 0;
  }
  void mutate_up(bool _up) {
    flatbuffers::WriteScalar(&up_, static_cast<uint8_t>(_up));
  }
  bool right() const {
    return flatbuffers::EndianScalar(right_) != 0;
  }
  void mutate_right(bool _right) {
    flatbuffers::WriteScalar(&right_, static_cast<uint8_t>(_right));
  }
  bool down() const {
    return flatbuffers::EndianScalar(down_) != 0;
  }
  void mutate_down(bool _down) {
    flatbuffers::WriteScalar(&down_, static_cast<uint8_t>(_down));
  }
  bool left() const {
    return flatbuffers::EndianScalar(left_) != 0;
  }
  void mutate_left(bool _left) {
    flatbuffers::WriteScalar(&left_, static_cast<uint8_t>(_left));
  }
  bool lt() const {
    return flatbuffers::EndianScalar(lt_) != 0;
  }
  void mutate_lt(bool _lt) {
    flatbuffers::WriteScalar(&lt_, static_cast<uint8_t>(_lt));
  }
  bool rt() const {
    return flatbuffers::EndianScalar(rt_) != 0;
  }
  void mutate_rt(bool _rt) {
    flatbuffers::WriteScalar(&rt_, static_cast<uint8_t>(_rt));
  }
  bool triangle() const {
    return flatbuffers::EndianScalar(triangle_) != 0;
  }
  void mutate_triangle(bool _triangle) {
    flatbuffers::WriteScalar(&triangle_, static_cast<uint8_t>(_triangle));
  }
  bool circle() const {
    return flatbuffers::EndianScalar(circle_) != 0;
  }
  void mutate_circle(bool _circle) {
    flatbuffers::WriteScalar(&circle_, static_cast<uint8_t>(_circle));
  }
  bool cross() const {
    return flatbuffers::EndianScalar(cross_) != 0;
  }
  void mutate_cross(bool _cross) {
    flatbuffers::WriteScalar(&cross_, static_cast<uint8_t>(_cross));
  }
  bool square() const {
    return flatbuffers::EndianScalar(square_) != 0;
  }
  void mutate_square(bool _square) {
    flatbuffers::WriteScalar(&square_, static_cast<uint8_t>(_square));
  }
};
FLATBUFFERS_STRUCT_END(ButtonsData, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3() {
    memset(static_cast<void *>(this), 0, sizeof(Vector3));
  }
  Vector3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Vector3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MotionData FLATBUFFERS_FINAL_CLASS {
 private:
  Pad::Vector3 gyro_;
  Pad::Vector3 accelerometer_;

 public:
  MotionData() {
    memset(static_cast<void *>(this), 0, sizeof(MotionData));
  }
  MotionData(const Pad::Vector3 &_gyro, const Pad::Vector3 &_accelerometer)
      : gyro_(_gyro),
        accelerometer_(_accelerometer) {
  }
  const Pad::Vector3 &gyro() const {
    return gyro_;
  }
  Pad::Vector3 &mutable_gyro() {
    return gyro_;
  }
  const Pad::Vector3 &accelerometer() const {
    return accelerometer_;
  }
  Pad::Vector3 &mutable_accelerometer() {
    return accelerometer_;
  }
};
FLATBUFFERS_STRUCT_END(MotionData, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) TouchReport FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t pressure_;
  uint8_t id_;
  int16_t x_;
  int16_t y_;

 public:
  TouchReport() {
    memset(static_cast<void *>(this), 0, sizeof(TouchReport));
  }
  TouchReport(uint8_t _pressure, uint8_t _id, int16_t _x, int16_t _y)
      : pressure_(flatbuffers::EndianScalar(_pressure)),
        id_(flatbuffers::EndianScalar(_id)),
        x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  uint8_t pressure() const {
    return flatbuffers::EndianScalar(pressure_);
  }
  void mutate_pressure(uint8_t _pressure) {
    flatbuffers::WriteScalar(&pressure_, _pressure);
  }
  uint8_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  void mutate_id(uint8_t _id) {
    flatbuffers::WriteScalar(&id_, _id);
  }
  int16_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(int16_t _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  int16_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(int16_t _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
};
FLATBUFFERS_STRUCT_END(TouchReport, 6);

struct TouchData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TouchDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4,
    VT_REPORTS = 6,
    VT_NUM_REPORTS = 8
  };
  Pad::TouchPort port() const {
    return static_cast<Pad::TouchPort>(GetField<uint8_t>(VT_PORT, 0));
  }
  bool mutate_port(Pad::TouchPort _port) {
    return SetField<uint8_t>(VT_PORT, static_cast<uint8_t>(_port), 0);
  }
  const flatbuffers::Vector<const Pad::TouchReport *> *reports() const {
    return GetPointer<const flatbuffers::Vector<const Pad::TouchReport *> *>(VT_REPORTS);
  }
  flatbuffers::Vector<const Pad::TouchReport *> *mutable_reports() {
    return GetPointer<flatbuffers::Vector<const Pad::TouchReport *> *>(VT_REPORTS);
  }
  uint8_t num_reports() const {
    return GetField<uint8_t>(VT_NUM_REPORTS, 0);
  }
  bool mutate_num_reports(uint8_t _num_reports) {
    return SetField<uint8_t>(VT_NUM_REPORTS, _num_reports, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PORT) &&
           VerifyOffset(verifier, VT_REPORTS) &&
           verifier.VerifyVector(reports()) &&
           VerifyField<uint8_t>(verifier, VT_NUM_REPORTS) &&
           verifier.EndTable();
  }
};

struct TouchDataBuilder {
  typedef TouchData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_port(Pad::TouchPort port) {
    fbb_.AddElement<uint8_t>(TouchData::VT_PORT, static_cast<uint8_t>(port), 0);
  }
  void add_reports(flatbuffers::Offset<flatbuffers::Vector<const Pad::TouchReport *>> reports) {
    fbb_.AddOffset(TouchData::VT_REPORTS, reports);
  }
  void add_num_reports(uint8_t num_reports) {
    fbb_.AddElement<uint8_t>(TouchData::VT_NUM_REPORTS, num_reports, 0);
  }
  explicit TouchDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TouchDataBuilder &operator=(const TouchDataBuilder &);
  flatbuffers::Offset<TouchData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TouchData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TouchData> CreateTouchData(
    flatbuffers::FlatBufferBuilder &_fbb,
    Pad::TouchPort port = Pad::TouchPort::Front,
    flatbuffers::Offset<flatbuffers::Vector<const Pad::TouchReport *>> reports = 0,
    uint8_t num_reports = 0) {
  TouchDataBuilder builder_(_fbb);
  builder_.add_reports(reports);
  builder_.add_num_reports(num_reports);
  builder_.add_port(port);
  return builder_.Finish();
}

inline flatbuffers::Offset<TouchData> CreateTouchDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Pad::TouchPort port = Pad::TouchPort::Front,
    const std::vector<Pad::TouchReport> *reports = nullptr,
    uint8_t num_reports = 0) {
  auto reports__ = reports ? _fbb.CreateVectorOfStructs<Pad::TouchReport>(*reports) : 0;
  return Pad::CreateTouchData(
      _fbb,
      port,
      reports__,
      num_reports);
}

struct MainPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MainPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUTTONS = 4,
    VT_LX = 6,
    VT_LY = 8,
    VT_RX = 10,
    VT_RY = 12,
    VT_TOUCH = 14,
    VT_MOTION = 16,
    VT_TIMESTAMP = 18
  };
  const Pad::ButtonsData *Buttons() const {
    return GetStruct<const Pad::ButtonsData *>(VT_BUTTONS);
  }
  Pad::ButtonsData *mutable_Buttons() {
    return GetStruct<Pad::ButtonsData *>(VT_BUTTONS);
  }
  uint8_t lx() const {
    return GetField<uint8_t>(VT_LX, 0);
  }
  bool mutate_lx(uint8_t _lx) {
    return SetField<uint8_t>(VT_LX, _lx, 0);
  }
  uint8_t ly() const {
    return GetField<uint8_t>(VT_LY, 0);
  }
  bool mutate_ly(uint8_t _ly) {
    return SetField<uint8_t>(VT_LY, _ly, 0);
  }
  uint8_t rx() const {
    return GetField<uint8_t>(VT_RX, 0);
  }
  bool mutate_rx(uint8_t _rx) {
    return SetField<uint8_t>(VT_RX, _rx, 0);
  }
  uint8_t ry() const {
    return GetField<uint8_t>(VT_RY, 0);
  }
  bool mutate_ry(uint8_t _ry) {
    return SetField<uint8_t>(VT_RY, _ry, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pad::TouchData>> *touch() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pad::TouchData>> *>(VT_TOUCH);
  }
  flatbuffers::Vector<flatbuffers::Offset<Pad::TouchData>> *mutable_touch() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Pad::TouchData>> *>(VT_TOUCH);
  }
  const Pad::MotionData *motion() const {
    return GetStruct<const Pad::MotionData *>(VT_MOTION);
  }
  Pad::MotionData *mutable_motion() {
    return GetStruct<Pad::MotionData *>(VT_MOTION);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Pad::ButtonsData>(verifier, VT_BUTTONS) &&
           VerifyField<uint8_t>(verifier, VT_LX) &&
           VerifyField<uint8_t>(verifier, VT_LY) &&
           VerifyField<uint8_t>(verifier, VT_RX) &&
           VerifyField<uint8_t>(verifier, VT_RY) &&
           VerifyOffset(verifier, VT_TOUCH) &&
           verifier.VerifyVector(touch()) &&
           verifier.VerifyVectorOfTables(touch()) &&
           VerifyField<Pad::MotionData>(verifier, VT_MOTION) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct MainPacketBuilder {
  typedef MainPacket Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Buttons(const Pad::ButtonsData *Buttons) {
    fbb_.AddStruct(MainPacket::VT_BUTTONS, Buttons);
  }
  void add_lx(uint8_t lx) {
    fbb_.AddElement<uint8_t>(MainPacket::VT_LX, lx, 0);
  }
  void add_ly(uint8_t ly) {
    fbb_.AddElement<uint8_t>(MainPacket::VT_LY, ly, 0);
  }
  void add_rx(uint8_t rx) {
    fbb_.AddElement<uint8_t>(MainPacket::VT_RX, rx, 0);
  }
  void add_ry(uint8_t ry) {
    fbb_.AddElement<uint8_t>(MainPacket::VT_RY, ry, 0);
  }
  void add_touch(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pad::TouchData>>> touch) {
    fbb_.AddOffset(MainPacket::VT_TOUCH, touch);
  }
  void add_motion(const Pad::MotionData *motion) {
    fbb_.AddStruct(MainPacket::VT_MOTION, motion);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(MainPacket::VT_TIMESTAMP, timestamp, 0);
  }
  explicit MainPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MainPacketBuilder &operator=(const MainPacketBuilder &);
  flatbuffers::Offset<MainPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MainPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<MainPacket> CreateMainPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Pad::ButtonsData *Buttons = 0,
    uint8_t lx = 0,
    uint8_t ly = 0,
    uint8_t rx = 0,
    uint8_t ry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pad::TouchData>>> touch = 0,
    const Pad::MotionData *motion = 0,
    uint64_t timestamp = 0) {
  MainPacketBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_motion(motion);
  builder_.add_touch(touch);
  builder_.add_Buttons(Buttons);
  builder_.add_ry(ry);
  builder_.add_rx(rx);
  builder_.add_ly(ly);
  builder_.add_lx(lx);
  return builder_.Finish();
}

inline flatbuffers::Offset<MainPacket> CreateMainPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Pad::ButtonsData *Buttons = 0,
    uint8_t lx = 0,
    uint8_t ly = 0,
    uint8_t rx = 0,
    uint8_t ry = 0,
    const std::vector<flatbuffers::Offset<Pad::TouchData>> *touch = nullptr,
    const Pad::MotionData *motion = 0,
    uint64_t timestamp = 0) {
  auto touch__ = touch ? _fbb.CreateVector<flatbuffers::Offset<Pad::TouchData>>(*touch) : 0;
  return Pad::CreateMainPacket(
      _fbb,
      Buttons,
      lx,
      ly,
      rx,
      ry,
      touch__,
      motion,
      timestamp);
}

inline const Pad::MainPacket *GetMainPacket(const void *buf) {
  return flatbuffers::GetRoot<Pad::MainPacket>(buf);
}

inline const Pad::MainPacket *GetSizePrefixedMainPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Pad::MainPacket>(buf);
}

inline MainPacket *GetMutableMainPacket(void *buf) {
  return flatbuffers::GetMutableRoot<MainPacket>(buf);
}

inline bool VerifyMainPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Pad::MainPacket>(nullptr);
}

inline bool VerifySizePrefixedMainPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Pad::MainPacket>(nullptr);
}

inline void FinishMainPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Pad::MainPacket> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMainPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Pad::MainPacket> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Pad

#endif  // FLATBUFFERS_GENERATED_PAD_PAD_H_
